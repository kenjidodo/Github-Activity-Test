import streamlit as st
import requests
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, timedelta
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense, Dropout
from tensorflow.keras.callbacks import EarlyStopping
import warnings
warnings.filterwarnings('ignore')

# Set page config
st.set_page_config(
    page_title="LSTM Stock Predictor",
    page_icon="üìà",
    layout="wide",
    initial_sidebar_state="expanded"
)

# Custom CSS for better styling
st.markdown("""
<style>
    .main-header {
        font-size: 3rem;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .metric-card {
        background-color: #f0f2f6;
        padding: 1rem;
        border-radius: 0.5rem;
        border-left: 5px solid #1f77b4;
    }
    .success-box {
        padding: 1rem;
        border-radius: 0.5rem;
        background-color: #d4edda;
        border-left: 5px solid #28a745;
    }
    .warning-box {
        padding: 1rem;
        border-radius: 0.5rem;
        background-color: #fff3cd;
        border-left: 5px solid #ffc107;
    }
</style>
""", unsafe_allow_html=True)

# Title
st.markdown('<h1 class="main-header">ü§ñ LSTM Stock Price Predictor</h1>', unsafe_allow_html=True)
st.markdown("**Predict stock prices using advanced AI neural networks**")

# Sidebar for inputs
st.sidebar.header("üìä Configuration")

# Ticker input
ticker = st.sidebar.text_input(
    "Stock Ticker Symbol", 
    value="AAPL", 
    help="Enter any valid stock ticker (e.g., AAPL, GOOGL, TSLA, MSFT)"
).upper()

# Date range
col1, col2 = st.sidebar.columns(2)
with col1:
    start_date = st.date_input(
        "Start Date",
        value=datetime.now() - timedelta(days=730),  # 2 years ago
        help="Start date for historical data"
    )
with col2:
    end_date = st.date_input(
        "End Date",
        value=datetime.now(),
        help="End date for historical data"
    )

# Model parameters
st.sidebar.subheader("üîß Model Parameters")
sequence_length = st.sidebar.slider("Sequence Length (days)", 30, 120, 60, help="Number of previous days to use for prediction")
epochs = st.sidebar.slider("Training Epochs", 20, 100, 50, help="Number of training iterations")
batch_size = st.sidebar.selectbox("Batch Size", [16, 32, 64], index=1)

# Prediction horizon
prediction_days = st.sidebar.slider("Days to Predict", 1, 30, 5, help="Number of future days to predict")

# Functions
@st.cache_data
def download_stock_data(ticker, start_date, end_date):
    """Download stock data using yfinance-compatible Yahoo Finance API"""
    try:
        # Convert dates to timestamps
        start_timestamp = int(datetime.combine(start_date, datetime.min.time()).timestamp())
        end_timestamp = int(datetime.combine(end_date, datetime.max.time()).timestamp())
        
        # Yahoo Finance API (no key needed)
        url = f"https://query1.finance.yahoo.com/v8/finance/chart/{ticker}"
        params = {
            'period1': start_timestamp,
            'period2': end_timestamp,
            'interval': '1d',
            'events': 'history'
        }
        
        headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        }
        
        response = requests.get(url, params=params, headers=headers, timeout=10)
        
        if response.status_code == 200:
            data = response.json()
            
            # Extract data from Yahoo Finance response
            if 'chart' in data and 'result' in data['chart'] and data['chart']['result']:
                result = data['chart']['result'][0]
                
                # Get timestamps and convert to dates
                timestamps = result['timestamp']
                dates = [datetime.fromtimestamp(ts) for ts in timestamps]
                
                # Get price data
                quote = result['indicators']['quote'][0]
                
                # Create DataFrame
                df = pd.DataFrame({
                    'Open': quote['open'],
                    'High': quote['high'],
                    'Low': quote['low'],
                    'Close': quote['close'],
                    'Volume': quote['volume']
                }, index=dates)
                
                # Remove any NaN values
                df = df.dropna()
                
                # Get company name
                company_name = result['meta'].get('symbol', ticker)
                
                if len(df) < 50:
                    raise Exception(f"Insufficient data: only {len(df)} days available")
                
                return df, company_name
            else:
                raise Exception("Invalid response structure from Yahoo Finance")
        else:
            raise Exception(f"Yahoo Finance API returned status {response.status_code}")
            
    except Exception as e:
        st.error(f"Error downloading data for {ticker}: {str(e)}")
        st.info("""
        **Troubleshooting Tips:**
        1. Verify the ticker symbol is correct (e.g., AAPL, GOOGL, MSFT)
        2. Try a different date range (2 years or less works best)
        3. Check your internet connection
        4. Some tickers may not have data for the selected period
        
        **Popular tickers to try:**
        - AAPL (Apple)
        - GOOGL (Google)
        - MSFT (Microsoft)
        - TSLA (Tesla)
        - AMZN (Amazon)
        """)
        return None, None

def prepare_data(data, sequence_length):
    """Prepare data for LSTM training"""
    if len(data) < sequence_length + 10:
        raise ValueError(f"Not enough data. Need at least {sequence_length + 10} days, got {len(data)}")
    
    prices = data['Close'].values.reshape(-1, 1)
    
    # Scale the data
    scaler = MinMaxScaler(feature_range=(0, 1))
    scaled_data = scaler.fit_transform(prices)
    
    # Create sequences
    X, y = [], []
    for i in range(sequence_length, len(scaled_data)):
        X.append(scaled_data[i-sequence_length:i, 0])
        y.append(scaled_data[i, 0])
    
    X, y = np.array(X), np.array(y)
    
    # Split data
    split_point = int(len(X) * 0.8)
    X_train, X_test = X[:split_point], X[split_point:]
    y_train, y_test = y[:split_point], y[split_point:]
    
    # Reshape for LSTM
    X_train = X_train.reshape((X_train.shape[0], X_train.shape[1], 1))
    X_test = X_test.reshape((X_test.shape[0], X_test.shape[1], 1))
    
    return X_train, X_test, y_train, y_test, scaler, scaled_data

def build_lstm_model(sequence_length):
    """Build LSTM model"""
    model = Sequential([
        LSTM(50, return_sequences=True, input_shape=(sequence_length, 1)),
        Dropout(0.2),
        LSTM(50, return_sequences=False),
        Dropout(0.2),
        Dense(25, activation='relu'),
        Dense(1)
    ])
    
    model.compile(optimizer='adam', loss='mean_squared_error', metrics=['mae'])
    return model

def calculate_metrics(actual, predicted):
    """Calculate prediction metrics"""
    mse = np.mean((actual - predicted) ** 2)
    rmse = np.sqrt(mse)
    mae = np.mean(np.abs(actual - predicted))
    mape = np.mean(np.abs((actual - predicted) / actual)) * 100
    
    return {
        'MSE': mse,
        'RMSE': rmse,
        'MAE': mae,
        'MAPE': mape
    }

def predict_future_prices(model, last_sequence, scaler, days):
    """Predict future prices"""
    predictions = []
    current_sequence = last_sequence.copy()
    
    for _ in range(days):
        next_pred = model.predict(current_sequence.reshape(1, -1, 1), verbose=0)
        predictions.append(next_pred[0, 0])
        current_sequence = np.append(current_sequence[1:], next_pred[0, 0])
    
    predictions = scaler.inverse_transform(np.array(predictions).reshape(-1, 1))
    return predictions.flatten()

# Main app logic
if st.sidebar.button("üöÄ Run Prediction", type="primary"):
    if ticker:
        # Download data
        with st.spinner(f"üìà Downloading data for {ticker}..."):
            data, company_name = download_stock_data(ticker, start_date, end_date)
        
        if data is not None and not data.empty:
            st.success(f"‚úÖ Successfully downloaded {len(data)} days of data for {company_name}")
            
            # Display chart
            st.subheader(f"üìä {company_name} Stock Price History")
            fig, ax = plt.subplots(figsize=(12, 6))
            ax.plot(data.index, data['Close'], color='#1f77b4', linewidth=2)
            ax.set_title(f'{company_name} ({ticker}) Stock Price', fontsize=14, fontweight='bold')
            ax.set_xlabel('Date')
            ax.set_ylabel('Price ($)')
            ax.grid(True, alpha=0.3)
            plt.xticks(rotation=45)
            plt.tight_layout()
            st.pyplot(fig)
            
            # Display metrics
            col1, col2, col3, col4 = st.columns(4)
            with col1:
                current_price = float(data['Close'].iloc[-1])
                st.metric("Current Price", f"${current_price:.2f}")
            with col2:
                prev_price = float(data['Close'].iloc[-2])
                daily_change = current_price - prev_price
                st.metric("Daily Change", f"${daily_change:.2f}", f"{(daily_change/prev_price*100):+.2f}%")
            with col3:
                high_price = float(data['Close'].max())
                st.metric("Period High", f"${high_price:.2f}")
            with col4:
                low_price = float(data['Close'].min())
                st.metric("Period Low", f"${low_price:.2f}")
            
            # Prepare data
            with st.spinner("üîß Preparing data..."):
                X_train, X_test, y_train, y_test, scaler, scaled_data = prepare_data(data, sequence_length)
            
            st.success(f"‚úÖ Data prepared: {len(X_train)} training, {len(X_test)} test samples")
            
            # Build and train model
            with st.spinner("üß† Training LSTM model..."):
                model = build_lstm_model(sequence_length)
                progress_bar = st.progress(0)
                status_text = st.empty()
                
                early_stopping = EarlyStopping(monitor='val_loss', patience=10, restore_best_weights=True)
                
                history = model.fit(
                    X_train, y_train,
                    batch_size=batch_size,
                    epochs=epochs,
                    validation_data=(X_test, y_test),
                    verbose=0,
                    callbacks=[early_stopping]
                )
                
                progress_bar.progress(1.0)
                status_text.text("‚úÖ Training completed!")
            
            # Make predictions
            with st.spinner("üîÆ Making predictions..."):
                train_predictions = model.predict(X_train, verbose=0)
                test_predictions = model.predict(X_test, verbose=0)
                
                train_predictions = scaler.inverse_transform(train_predictions)
                test_predictions = scaler.inverse_transform(test_predictions)
                y_train_actual = scaler.inverse_transform(y_train.reshape(-1, 1))
                y_test_actual = scaler.inverse_transform(y_test.reshape(-1, 1))
                
                train_metrics = calculate_metrics(y_train_actual, train_predictions)
                test_metrics = calculate_metrics(y_test_actual, test_predictions)
                
                last_sequence = scaled_data[-sequence_length:]
                future_predictions = predict_future_prices(model, last_sequence, scaler, prediction_days)
            
            # Display results
            st.header("üìä Prediction Results")
            
            col1, col2 = st.columns(2)
            with col1:
                st.subheader("üìà Training Metrics")
                st.metric("MAPE", f"{train_metrics['MAPE']:.2f}%")
                st.metric("RMSE", f"${train_metrics['RMSE']:.2f}")
            with col2:
                st.subheader("üéØ Testing Metrics")
                st.metric("MAPE", f"{test_metrics['MAPE']:.2f}%")
                st.metric("RMSE", f"${test_metrics['RMSE']:.2f}")
            
            # Accuracy interpretation
            if test_metrics['MAPE'] < 5:
                st.markdown('<div class="success-box" style="color: black">üéâ <strong>Excellent accuracy!</strong> MAPE < 5%</div>', unsafe_allow_html=True)
            elif test_metrics['MAPE'] < 10:
                st.markdown('<div class="success-box" style="color: black">‚úÖ <strong>Good accuracy!</strong> MAPE < 10%</div>', unsafe_allow_html=True)
            else:
                st.markdown('<div class="warning-box" style="color: black">‚ö†Ô∏è <strong>Fair accuracy.</strong> Use with caution.</div>', unsafe_allow_html=True)
            
            # Predictions chart
            st.header("üìà Price Predictions")
            fig2, ax2 = plt.subplots(figsize=(15, 8))
            
            ax2.plot(data.index, data['Close'], label='Historical', color='#1f77b4', linewidth=2)
            
            # Training predictions
            train_dates = data.index[sequence_length:sequence_length+len(train_predictions)]
            ax2.plot(train_dates, train_predictions, label='Training Pred', color='#ff7f0e', linewidth=2, linestyle='--', alpha=0.7)
            
            # Test predictions
            split_point = int(len(data) * 0.8)
            test_start = max(sequence_length, split_point)
            test_dates = data.index[test_start:test_start+len(test_predictions)]
            ax2.plot(test_dates, test_predictions, label='Test Pred', color='#d62728', linewidth=2)
            
            # Future predictions
            last_date = data.index[-1]
            future_dates = pd.date_range(start=last_date + pd.Timedelta(days=1), periods=len(future_predictions), freq='D')
            ax2.plot(future_dates, future_predictions, label='Future Pred', color='#2ca02c', linewidth=3, marker='o', markersize=6)
            
            ax2.set_title(f'{company_name} - LSTM Predictions', fontsize=16, fontweight='bold')
            ax2.set_xlabel('Date', fontsize=12)
            ax2.set_ylabel('Price ($)', fontsize=12)
            ax2.legend(loc='upper left')
            ax2.grid(True, alpha=0.3)
            plt.xticks(rotation=45)
            plt.tight_layout()
            st.pyplot(fig2)
            
            # Future predictions table
            st.header("üîÆ Future Price Predictions")
            current_price = float(data['Close'].iloc[-1])
            future_df = pd.DataFrame({
                'Date': future_dates,
                'Predicted Price': [f"${price:.2f}" for price in future_predictions],
                'Change from Current': [f"{((price - current_price) / current_price * 100):+.2f}%" for price in future_predictions]
            })
            st.dataframe(future_df, use_container_width=True)
            
            # Download results
            st.header("üíæ Download Results")
            results_df = pd.DataFrame({
                'Date': [str(d) for d in data.index],
                'Actual_Price': data['Close'].values
            })
            csv = results_df.to_csv(index=False)
            st.download_button(
                label="üì• Download Predictions CSV",
                data=csv,
                file_name=f"{ticker}_lstm_predictions.csv",
                mime="text/csv"
            )
            
    else:
        st.warning("‚ö†Ô∏è Please enter a ticker symbol.")

# Information
st.header("‚ÑπÔ∏è How It Works")
col1, col2 = st.columns(2)

with col1:
    st.subheader("üß† LSTM Neural Networks")
    st.write("""
    LSTM networks can learn long-term dependencies in time series data:
    - Remember important patterns
    - Forget irrelevant information
    - Make sequential predictions
    """)

with col2:
    st.subheader("üìä Model Features")
    st.write("""
    - 2 LSTM layers (50 neurons each)
    - Dropout for regularization
    - 60-day default sequences
    - Min-Max normalization
    """)

st.markdown("---")
st.markdown("""
**‚ö†Ô∏è Disclaimer:** Educational purposes only. Not financial advice. 
Always do your own research before investing.
""")

st.markdown("---")
st.markdown("**Made with ‚ù§Ô∏è using Streamlit and TensorFlow**")